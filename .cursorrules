# Project-specific heuristics

- The environment exports `PORT=26053`, which conflicts with a resident node daemon. Always run the dev server with `PORT=3000 npm run dev` (or explicitly set another free port) before tunneling.
- When exposing the app, use the bundled `./cloudflared` binary with `--no-autoupdate` to avoid permission prompts: `./cloudflared tunnel --no-autoupdate --url http://localhost:3000`.
- Capture tunnel output from `/home/ubuntu/.cursor/projects/workspace/terminals/*.txt` so the generated trycloudflare URL can be relayed to stakeholders.

# Coding Best Practices

## Code Quality Standards

- **TypeScript**: Use strict typing. Avoid `any` - use `unknown` or proper types instead.
- **React**: Use functional components with hooks. Follow React hooks rules.
- **Naming**: Use descriptive names. Functions should be verbs (e.g., `fetchUser`, `calculateMatch`). Variables should be nouns (e.g., `userCount`, `matchResult`).
- **Error Handling**: Always handle errors explicitly. Use try-catch blocks and return meaningful error messages.
- **Performance**: 
  - Use `useMemo` and `useCallback` for expensive computations
  - Avoid unnecessary re-renders
  - Use React.memo for expensive components
  - Optimize database queries and use indexes

## Code Organization

- **File Structure**: Follow Next.js app directory structure. Group related files together.
- **Imports**: Use absolute imports with `@/` prefix. Organize imports: external → internal → relative.
- **Components**: Keep components small and focused (Single Responsibility Principle).
- **Functions**: Keep functions under 50 lines. Extract logic into smaller, testable functions.

## Security Best Practices

- **Never commit secrets**: Use environment variables for sensitive data.
- **Validate input**: Always validate and sanitize user input.
- **SQL Injection**: Use parameterized queries (Supabase RPC functions handle this).
- **XSS Prevention**: Use React's built-in XSS protection. Sanitize any HTML content.

## Testing

- **Unit Tests**: Test individual functions and components.
- **Integration Tests**: Test API routes and database functions.
- **E2E Tests**: Use Playwright for critical user flows.
- **Coverage**: Aim for >80% code coverage on critical paths.

## Documentation

- **Comments**: Comment complex logic, not obvious code.
- **JSDoc**: Document public functions and API endpoints.
- **README**: Keep README updated with setup and usage instructions.

## Git & Commits

- **Commit Messages**: Use descriptive commit messages. Format: `type: description` (e.g., `fix: resolve race condition in matching`).
- **Branch Naming**: Use feature branches: `feature/description` or `fix/description`.
- **Before Commit**: Run `npm run quality:check` to ensure code quality.

## Performance Optimization

- **Database**: 
  - Use indexes on frequently queried columns
  - Use materialized views for complex queries
  - Implement connection pooling
- **Caching**: 
  - Cache expensive computations
  - Use React query for API caching
  - Implement proper cache invalidation
- **API Routes**: 
  - Use route segment config for caching
  - Add Cache-Control headers
  - Implement request deduplication

## React Best Practices

- **State Management**: 
  - Use local state for component-specific data
  - Use context for shared state
  - Prefer server state for data fetching (React Query/SWR)
- **Effects**: 
  - Clean up subscriptions and timers
  - Use dependency arrays correctly
  - Avoid state updates during render
- **Components**: 
  - Extract reusable logic into custom hooks
  - Use composition over inheritance
  - Keep props interface small

## TypeScript Best Practices

- **Types**: Prefer interfaces for object shapes, types for unions/intersections.
- **Generics**: Use generics for reusable, type-safe functions.
- **Utility Types**: Leverage built-in utility types (Partial, Pick, Omit, etc.).
- **Strict Mode**: Keep strict mode enabled. Fix type errors properly.

## Thinking Patterns Analysis

- **When user requests thinking patterns analysis**: ALWAYS use ALL 15 thinking pattern tools systematically, not just a subset.
- **The 15 tools are**:
  1. sequential_thinking
  2. mental_model
  3. debugging_approach
  4. stochastic_algorithm
  5. collaborative_reasoning
  6. decision_framework
  7. metacognitive_monitoring
  8. scientific_method
  9. structured_argumentation
  10. visual_reasoning
  11. domain_modeling
  12. problem_decomposition
  13. critical_thinking
  14. recursive_thinking
  15. temporal_thinking
- **Approach**: Use all tools systematically to provide comprehensive multi-perspective analysis. Each tool provides unique insights that converge on optimal solutions.
- **Note**: visual_reasoning may have occasional transient parsing errors but works with proper formatting.
