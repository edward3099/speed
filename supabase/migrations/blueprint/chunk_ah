-- Guardian 1: Remove offline users
CREATE OR REPLACE FUNCTION guardian_remove_offline()
RETURNS INTEGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  removed_count INTEGER := 0;
  user_record RECORD;
BEGIN
  -- Find users offline for more than 20 seconds
  FOR user_record IN
    SELECT user_id
    FROM user_status
    WHERE online_status = TRUE
      AND last_heartbeat < NOW() - INTERVAL '20 seconds'
  LOOP
    -- Mark as offline
    UPDATE users SET online = FALSE WHERE id = user_record.user_id;
    UPDATE user_status
    SET state = 'offline',
        online_status = FALSE,
        last_state = state,
        last_state_change = NOW(),
        updated_at = NOW()
    WHERE user_id = user_record.user_id;
    
    -- Remove from queue
    DELETE FROM queue WHERE user_id = user_record.user_id;
    
    -- Break active matches and apply cooldown
    PERFORM set_cooldown(user_record.user_id);
    
    removed_count := removed_count + 1;
  END LOOP;
  
  RETURN removed_count;
END;
$$;

-- Guardian 2: Remove stale matches
CREATE OR REPLACE FUNCTION guardian_remove_stale_matches()
RETURNS INTEGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  cleaned_count INTEGER := 0;
  match_record RECORD;
  partner_id UUID;
BEGIN
  -- Find stale matches (vote_active for more than 15 seconds)
  FOR match_record IN
    SELECT id, user1_id, user2_id
    FROM matches
    WHERE status = 'vote_active'
      AND vote_window_expires_at < NOW() - INTERVAL '5 seconds'
  LOOP
    -- Get partner
    -- Check votes to see if one voted yes
    IF EXISTS (
      SELECT 1 FROM votes
      WHERE match_id = match_record.id AND vote_type = 'yes'
    ) THEN
      -- One voted yes, give boost
      SELECT voter_id INTO partner_id
      FROM votes
      WHERE match_id = match_record.id AND vote_type = 'yes'
      LIMIT 1;
      
      PERFORM apply_yes_boost(partner_id);
      PERFORM execute_state_transition(partner_id, 'spin_active');
    END IF;
    
    -- Clean up match
    DELETE FROM matches WHERE id = match_record.id;
    DELETE FROM votes WHERE match_id = match_record.id;
    
    -- Set both to idle
    UPDATE user_status
    SET state = 'idle',
        last_state = 'vote_active',
        last_state_change = NOW(),
        updated_at = NOW()
    WHERE user_id IN (match_record.user1_id, match_record.user2_id);
    
    cleaned_count := cleaned_count + 1;
  END LOOP;
  
  RETURN cleaned_count;
END;
$$;

-- Guardian 3: Enforce preference expansion
CREATE OR REPLACE FUNCTION guardian_enforce_expansion()
RETURNS INTEGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  updated_count INTEGER := 0;
BEGIN
  -- Update preference stages for all users in queue
  UPDATE queue q
  SET preference_stage = CASE
    WHEN EXTRACT(EPOCH FROM (NOW() - spin_started_at)) >= 20 THEN 3
    WHEN EXTRACT(EPOCH FROM (NOW() - spin_started_at)) >= 15 THEN 2
    WHEN EXTRACT(EPOCH FROM (NOW() - spin_started_at)) >= 10 THEN 1
    ELSE 0
  END,
  updated_at = NOW()
  WHERE preference_stage != CASE
    WHEN EXTRACT(EPOCH FROM (NOW() - spin_started_at)) >= 20 THEN 3
    WHEN EXTRACT(EPOCH FROM (NOW() - spin_started_at)) >= 15 THEN 2
    WHEN EXTRACT(EPOCH FROM (NOW() - spin_started_at)) >= 10 THEN 1
    ELSE 0
  END;
  
  GET DIAGNOSTICS updated_count = ROW_COUNT;
  RETURN updated_count;
END;
$$;

-- Main guardian job (runs every 10 seconds)
CREATE OR REPLACE FUNCTION guardian_job()
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  result JSONB;
BEGIN
  result := jsonb_build_object(
    'offline_removed', guardian_remove_offline(),
    'stale_matches_cleaned', guardian_remove_stale_matches(),
    'expansions_updated', guardian_enforce_expansion(),
    'timestamp', NOW()
  );
  
  RETURN result;
END;
$$;

COMMENT ON FUNCTION guardian_remove_offline IS 'Guardian 1: Removes offline users, breaks matches, applies cooldown';
COMMENT ON FUNCTION guardian_remove_stale_matches IS 'Guardian 2: Removes stale matches, applies boosts';
COMMENT ON FUNCTION guardian_enforce_expansion IS 'Guardian 3: Enforces preference expansion based on wait time';
COMMENT ON FUNCTION guardian_job IS 'Main guardian job - runs all guardians';


-- ============================================================================
-- 112_disconnect_handler.sql
-- ============================================================================

-- ============================================================================
-- Migration 112: Disconnect Handler
-- ============================================================================
-- Part 4.7: Disconnection behavior
-- ============================================================================

-- Handle user disconnect
CREATE OR REPLACE FUNCTION handle_disconnect(p_user_id UUID)
RETURNS VOID
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  active_match RECORD;
  partner_id UUID;
  partner_vote TEXT;
BEGIN
  -- Get active match if exists
  SELECT * INTO active_match
  FROM matches
  WHERE (user1_id = p_user_id OR user2_id = p_user_id)
    AND status IN ('pending', 'vote_active')
  LIMIT 1;
  
  IF FOUND THEN
    -- Get partner ID
    partner_id := CASE 
      WHEN active_match.user1_id = p_user_id THEN active_match.user2_id
      ELSE active_match.user1_id
    END;
    
    -- Check if partner voted yes
    SELECT vote_type INTO partner_vote
    FROM votes
    WHERE match_id = active_match.id AND voter_id = partner_id;
    
    -- If partner voted yes, give boost and auto respin
    IF partner_vote = 'yes' THEN
      PERFORM apply_yes_boost(partner_id);
      PERFORM execute_state_transition(partner_id, 'spin_active');
      PERFORM join_queue(partner_id);
    END IF;
    
    -- Break match
    DELETE FROM matches WHERE id = active_match.id;
    DELETE FROM votes WHERE match_id = active_match.id;
  END IF;
