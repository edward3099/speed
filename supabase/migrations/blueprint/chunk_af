    -- Add to never_pair_again (mutual pass)
    INSERT INTO never_pair_again (user1, user2, reason)
    VALUES (
      LEAST(p_user_id, partner_id),
      GREATEST(p_user_id, partner_id),
      'mutual_pass'
    )
    ON CONFLICT DO NOTHING;
    
    result := jsonb_build_object('outcome', 'yes_pass', 'next_state', 'respin');
    
  ELSIF p_vote_type = 'pass' AND partner_vote = 'pass' THEN
    -- Case 5: Both pass → both idle + never_pair_again
    DELETE FROM matches WHERE id = p_match_id;
    DELETE FROM votes WHERE match_id = p_match_id;
    
    UPDATE user_status
    SET state = 'idle',
        last_state = 'vote_active',
        last_state_change = NOW(),
        updated_at = NOW()
    WHERE user_id IN (p_user_id, partner_id);
    
    -- Add to never_pair_again
    INSERT INTO never_pair_again (user1, user2, reason)
    VALUES (
      LEAST(p_user_id, partner_id),
      GREATEST(p_user_id, partner_id),
      'mutual_pass'
    )
    ON CONFLICT DO NOTHING;
    
    result := jsonb_build_object('outcome', 'both_pass', 'next_state', 'idle');
    
  ELSE
    -- Waiting for partner's vote
    result := jsonb_build_object('outcome', 'waiting', 'status', 'vote_active');
  END IF;
  
  RETURN result;
END;
$$;

-- Handle idle voter (countdown expired, no vote)
CREATE OR REPLACE FUNCTION handle_idle_voter(p_user_id UUID, p_match_id BIGINT)
RETURNS VOID
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  partner_id UUID;
  partner_vote TEXT;
BEGIN
  -- Get partner ID
  SELECT 
    CASE WHEN user1_id = p_user_id THEN user2_id ELSE user1_id END
  INTO partner_id
  FROM matches
  WHERE id = p_match_id;
  
  -- Get partner's vote
  SELECT vote_type INTO partner_vote
  FROM votes
  WHERE match_id = p_match_id AND voter_id = partner_id;
  
  -- Case 4: Yes + Idle → idle user removed, yes voter +10 + auto respin
  IF partner_vote = 'yes' THEN
    -- Partner voted yes, current user is idle
    PERFORM apply_yes_boost(partner_id);
    
    UPDATE user_status
    SET state = 'spin_active',
        last_state = 'vote_active',
        last_state_change = NOW(),
        updated_at = NOW()
    WHERE user_id = partner_id;
  END IF;
  
  -- Idle user goes to idle (must spin manually)
  UPDATE user_status
  SET state = 'idle',
      last_state = 'vote_active',
      last_state_change = NOW(),
      updated_at = NOW()
  WHERE user_id = p_user_id;
  
  -- Clean up match
  DELETE FROM matches WHERE id = p_match_id;
  DELETE FROM votes WHERE match_id = p_match_id;
END;
$$;

COMMENT ON FUNCTION record_vote IS 'Records vote and resolves outcomes: both_yes, yes_pass, both_pass, waiting';
COMMENT ON FUNCTION handle_idle_voter IS 'Handles idle voter: removes idle user, gives yes voter boost if applicable';


-- ============================================================================
-- 107_cooldown_engine.sql
-- ============================================================================

-- ============================================================================
-- Migration 107: Cooldown Engine
-- ============================================================================
-- Part 5.8: Cooldown management (5 minutes)
-- ============================================================================

-- Set cooldown for user (5 minutes)
CREATE OR REPLACE FUNCTION set_cooldown(p_user_id UUID)
RETURNS VOID
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  -- Set cooldown_until to 5 minutes from now (update profiles table)
  UPDATE profiles
  SET cooldown_until = NOW() + INTERVAL '5 minutes',
      updated_at = NOW()
  WHERE id = p_user_id;
  
  -- Update user_status to cooldown
  UPDATE user_status
  SET state = 'cooldown',
      last_state = state,
      last_state_change = NOW(),
      updated_at = NOW()
  WHERE user_id = p_user_id;
  
  -- Remove from queue
  DELETE FROM queue WHERE user_id = p_user_id;
  
  -- Break any active matches
  UPDATE matches
  SET status = 'cancelled'
  WHERE (user1_id = p_user_id OR user2_id = p_user_id)
    AND status IN ('pending', 'vote_active');
  
  -- Log cooldown
  INSERT INTO debug_logs (user_id, event_type, metadata, severity)
  VALUES (p_user_id, 'cooldown_applied', jsonb_build_object('duration_minutes', 5), 'warning');
END;
$$;

-- Check if user is in cooldown
CREATE OR REPLACE FUNCTION is_in_cooldown(p_user_id UUID)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  cooldown_until TIMESTAMPTZ;
BEGIN
  SELECT cooldown_until INTO cooldown_until
  FROM profiles
  WHERE id = p_user_id;
  
  RETURN cooldown_until IS NOT NULL AND cooldown_until > NOW();
END;
$$;

COMMENT ON FUNCTION set_cooldown IS 'Sets 5-minute cooldown for user (applied on disconnect)';
COMMENT ON FUNCTION is_in_cooldown IS 'Checks if user is currently in cooldown';


-- ============================================================================
-- 108_blocklist_engine.sql
-- ============================================================================

-- ============================================================================
-- Migration 108: Blocklist Engine
-- ============================================================================
-- Part 5.7: Never pair again management
-- ============================================================================

-- Add pair to never_pair_again blocklist
CREATE OR REPLACE FUNCTION add_to_blocklist(
  p_user1 UUID,
  p_user2 UUID,
  p_reason TEXT
)
RETURNS VOID
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  -- Insert symmetric (lowest UUID first)
  INSERT INTO never_pair_again (user1, user2, reason)
  VALUES (
    LEAST(p_user1, p_user2),
    GREATEST(p_user1, p_user2),
    p_reason
  )
  ON CONFLICT DO NOTHING;
  
  -- Log blocklist addition
  INSERT INTO debug_logs (user_id, event_type, metadata, severity)
  VALUES (
    p_user1,
    'blocklist_added',
    jsonb_build_object('blocked_user', p_user2, 'reason', p_reason),
    'info'
