    -- Lock user2
    SELECT * INTO user2_record
    FROM profiles
    WHERE id = p_user2_id
    FOR UPDATE SKIP LOCKED;
    
    IF NOT FOUND THEN
      RETURN NULL;
    END IF;
    
    locked_user2 := TRUE;
  ELSE
    -- Lock user2 first
    SELECT * INTO user2_record
    FROM profiles
    WHERE id = p_user2_id
    FOR UPDATE SKIP LOCKED;
    
    IF NOT FOUND THEN
      RETURN NULL;
    END IF;
    
    locked_user2 := TRUE;
    
    -- Lock user1
    SELECT * INTO user1_record
    FROM profiles
    WHERE id = p_user1_id
    FOR UPDATE SKIP LOCKED;
    
    IF NOT FOUND THEN
      RETURN NULL;
    END IF;
    
    locked_user1 := TRUE;
  END IF;
  
  -- 2. Validate eligibility (re-check inside lock)
  -- Both must be online
  IF NOT user1_record.online OR NOT user2_record.online THEN
    RETURN NULL;
  END IF;
  
  -- Both must not be in cooldown
  IF (user1_record.cooldown_until IS NOT NULL AND user1_record.cooldown_until > NOW()) OR
     (user2_record.cooldown_until IS NOT NULL AND user2_record.cooldown_until > NOW()) THEN
    RETURN NULL;
  END IF;
  
  -- Check user_status: both must be spin_active or queue_waiting
  IF NOT EXISTS (
    SELECT 1 FROM user_status WHERE user_id = p_user1_id AND state IN ('spin_active', 'queue_waiting')
  ) OR NOT EXISTS (
    SELECT 1 FROM user_status WHERE user_id = p_user2_id AND state IN ('spin_active', 'queue_waiting')
  ) THEN
    RETURN NULL;
  END IF;
  
  -- Check never_pair_again (symmetric check)
  IF EXISTS (
    SELECT 1 FROM never_pair_again
    WHERE (user1 = p_user1_id AND user2 = p_user2_id)
       OR (user1 = p_user2_id AND user2 = p_user1_id)
  ) THEN
    RETURN NULL;
  END IF;
  
  -- Check neither already paired
  IF EXISTS (
    SELECT 1 FROM matches
    WHERE (user1_id = p_user1_id OR user2_id = p_user1_id)
      AND status IN ('pending', 'vote_active')
  ) OR EXISTS (
    SELECT 1 FROM matches
    WHERE (user1_id = p_user2_id OR user2_id = p_user2_id)
      AND status IN ('pending', 'vote_active')
  ) THEN
    RETURN NULL;
  END IF;
  
  -- 3. Create match (ensure user1_id < user2_id for consistency)
  INSERT INTO matches (user1_id, user2_id, status, created_at)
  VALUES (
    LEAST(p_user1_id, p_user2_id),
    GREATEST(p_user1_id, p_user2_id),
    'pending',
    NOW()
  )
  RETURNING id INTO match_id;
  
  -- 4. Update both user_status to paired
  UPDATE user_status
  SET state = 'paired',
      last_state = state,
      last_state_change = NOW(),
      updated_at = NOW()
  WHERE user_id IN (p_user1_id, p_user2_id);
  
  -- 5. Remove both from queue
  DELETE FROM queue WHERE user_id IN (p_user1_id, p_user2_id);
  
  RETURN match_id;
END;
$$;

COMMENT ON FUNCTION create_pair_atomic IS 'Atomic pairing engine - locks both users, validates eligibility, creates match, updates states';


-- ============================================================================
-- 102_find_best_match.sql
-- ============================================================================

-- ============================================================================
-- Migration 102: Find Best Match
-- ============================================================================
-- Part 5.3: Priority scoring and candidate selection
-- ============================================================================

-- Find best match for a user based on priority scoring
CREATE OR REPLACE FUNCTION find_best_match(
  p_user_id UUID,
  p_preference_stage INTEGER
) RETURNS UUID
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  candidate_id UUID;
  user_gender TEXT;
  user_prefs RECORD;
  best_candidate UUID;
  best_score DECIMAL(10, 2) := -1;
  candidate_score DECIMAL(10, 2);
  candidate_record RECORD;
BEGIN
  -- Get user gender (from profiles table)
  SELECT gender INTO user_gender FROM profiles WHERE id = p_user_id;
  
  -- Get user preferences
  SELECT * INTO user_prefs
  FROM user_preferences
  WHERE user_id = p_user_id;
  
  -- If no preferences, return NULL
  IF NOT FOUND THEN
    RETURN NULL;
  END IF;
  
  -- Find candidates based on preference stage
  FOR candidate_record IN
    SELECT 
      q.user_id,
      q.fairness_score,
      EXTRACT(EPOCH FROM (NOW() - q.spin_started_at))::INTEGER as wait_time_seconds,
      u.gender,
      up.min_age,
      up.max_age,
      up.max_distance,
      -- Calculate compatibility score based on preference stage
      CASE
        WHEN p_preference_stage = 0 THEN
          -- Stage 0: exact preferences only
          -- Check age compatibility (partner's age vs user's preferences)
          CASE 
            WHEN (up.min_age <= get_user_age(q.user_id) AND 
                  up.max_age >= get_user_age(q.user_id)) THEN 50
            ELSE 0
          END +
          -- Check distance compatibility (simplified - implement based on your location system)
          CASE
            WHEN up.max_distance >= COALESCE(get_user_distance(p_user_id, q.user_id), 999) THEN 50
            ELSE 0
          END
        WHEN p_preference_stage = 1 THEN
          -- Stage 1: age expanded ±2 years
          CASE 
            WHEN (up.min_age - 2 <= get_user_age(q.user_id) AND 
                  up.max_age + 2 >= get_user_age(q.user_id)) THEN 20
            ELSE 0
          END +
          CASE
            WHEN up.max_distance >= COALESCE(get_user_distance(p_user_id, q.user_id), 999) THEN 50
            ELSE 0
          END
        WHEN p_preference_stage = 2 THEN
          -- Stage 2: age ±4 years, distance × 1.5
          CASE 
            WHEN (up.min_age - 4 <= get_user_age(q.user_id) AND 
                  up.max_age + 4 >= get_user_age(q.user_id)) THEN 20
            ELSE 0
          END +
          CASE
            WHEN (up.max_distance * 1.5) >= COALESCE(get_user_distance(p_user_id, q.user_id), 999) THEN 20
            ELSE 0
          END
        ELSE
          -- Stage 3: full expansion (age and distance relaxed, but gender still strict)
          0
      END as compatibility_score
    FROM queue q
