  END IF;
END $$;

CREATE INDEX IF NOT EXISTS idx_matches_user1 ON matches(user1_id);
CREATE INDEX IF NOT EXISTS idx_matches_user2 ON matches(user2_id);
CREATE INDEX IF NOT EXISTS idx_matches_status ON matches(status);

-- Only create vote_window index if column exists
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'matches' AND column_name = 'vote_window_expires_at') THEN
    IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_matches_vote_window') THEN
      EXECUTE 'CREATE INDEX idx_matches_vote_window ON matches(vote_window_expires_at) WHERE vote_window_expires_at IS NOT NULL';
    END IF;
  END IF;
END $$;

COMMENT ON TABLE matches IS 'Pairing table - enforces one active match per user';


-- ============================================================================
-- 005_votes_table.sql
-- ============================================================================

-- ============================================================================
-- Migration 005: Votes Table
-- ============================================================================
-- Part 5.1: Vote storage
-- ============================================================================

-- Votes table: stores yes or pass votes
-- NOTE: References profiles(id) since we're using profiles as users

-- First, ensure columns exist if table already exists
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'votes') THEN
    -- Add match_id if missing
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'votes' AND column_name = 'match_id') THEN
      ALTER TABLE votes ADD COLUMN match_id BIGINT REFERENCES matches(id) ON DELETE CASCADE;
    END IF;
    -- Add voter_id if missing
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'votes' AND column_name = 'voter_id') THEN
      ALTER TABLE votes ADD COLUMN voter_id UUID REFERENCES profiles(id) ON DELETE CASCADE;
    END IF;
    -- Add vote_type if missing
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'votes' AND column_name = 'vote_type') THEN
      ALTER TABLE votes ADD COLUMN vote_type TEXT CHECK (vote_type IN ('yes', 'pass'));
    END IF;
    -- Add created_at if missing
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'votes' AND column_name = 'created_at') THEN
      ALTER TABLE votes ADD COLUMN created_at TIMESTAMPTZ NOT NULL DEFAULT NOW();
    END IF;
  END IF;
END $$;

-- Now create the table (will be no-op if it exists)
CREATE TABLE IF NOT EXISTS votes (
  match_id BIGINT NOT NULL REFERENCES matches(id) ON DELETE CASCADE,
  voter_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  vote_type TEXT NOT NULL CHECK (vote_type IN ('yes', 'pass')),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  PRIMARY KEY (match_id, voter_id)
);

-- Ensure columns exist one more time (in case table was just created)
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'votes' AND column_name = 'match_id') THEN
    ALTER TABLE votes ADD COLUMN match_id BIGINT REFERENCES matches(id) ON DELETE CASCADE;
  END IF;
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'votes' AND column_name = 'voter_id') THEN
    ALTER TABLE votes ADD COLUMN voter_id UUID REFERENCES profiles(id) ON DELETE CASCADE;
  END IF;
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'votes' AND column_name = 'vote_type') THEN
    ALTER TABLE votes ADD COLUMN vote_type TEXT CHECK (vote_type IN ('yes', 'pass'));
  END IF;
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'votes' AND column_name = 'created_at') THEN
    ALTER TABLE votes ADD COLUMN created_at TIMESTAMPTZ NOT NULL DEFAULT NOW();
  END IF;
END $$;

-- Create indexes only if columns exist
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'votes' AND column_name = 'match_id') THEN
    IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_votes_match') THEN
      EXECUTE 'CREATE INDEX idx_votes_match ON votes(match_id)';
    END IF;
  END IF;
  IF EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'votes' AND column_name = 'voter_id') THEN
    IF NOT EXISTS (SELECT 1 FROM pg_indexes WHERE indexname = 'idx_votes_voter') THEN
      EXECUTE 'CREATE INDEX idx_votes_voter ON votes(voter_id)';
    END IF;
  END IF;
END $$;

COMMENT ON TABLE votes IS 'Vote storage - stores yes or pass votes for each match';


-- ============================================================================
-- 006_never_pair_again_table.sql
-- ============================================================================

-- ============================================================================
-- Migration 006: Never Pair Again Table
-- ============================================================================
-- Part 5.1: Permanent blocklist
-- ============================================================================

-- Never pair again table: permanent ban list
-- NOTE: References profiles(id) since we're using profiles as users
CREATE TABLE IF NOT EXISTS never_pair_again (
  user1 UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  user2 UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  reason TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  PRIMARY KEY (user1, user2),
  CHECK (user1 < user2) -- Ensure symmetric storage (lowest UUID first)
);

CREATE INDEX IF NOT EXISTS idx_never_pair_again_user1 ON never_pair_again(user1);
CREATE INDEX IF NOT EXISTS idx_never_pair_again_user2 ON never_pair_again(user2);

COMMENT ON TABLE never_pair_again IS 'Permanent blocklist - pairs that can never be matched again';


-- ============================================================================
-- 007_debug_logs_table.sql
-- ============================================================================

-- ============================================================================
-- Migration 007: Debug Logs Table
-- ============================================================================
-- Part 5.1: System observability
-- ============================================================================

-- Debug logs table: central debug table for all events
-- NOTE: References profiles(id) since we're using profiles as users
CREATE TABLE IF NOT EXISTS debug_logs (
  id BIGSERIAL PRIMARY KEY,
  user_id UUID REFERENCES profiles(id) ON DELETE SET NULL,
  event_type TEXT NOT NULL,
  state_before JSONB,
  state_after JSONB,
  metadata JSONB,
  severity TEXT NOT NULL DEFAULT 'info' CHECK (severity IN ('debug', 'info', 'warning', 'error', 'critical')),
  timestamp TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_debug_logs_user ON debug_logs(user_id);
CREATE INDEX IF NOT EXISTS idx_debug_logs_event_type ON debug_logs(event_type);
CREATE INDEX IF NOT EXISTS idx_debug_logs_timestamp ON debug_logs(timestamp DESC);
CREATE INDEX IF NOT EXISTS idx_debug_logs_severity ON debug_logs(severity);

COMMENT ON TABLE debug_logs IS 'Central debug table for all events - system observability';


-- ============================================================================
-- 101_create_pair_atomic.sql
-- ============================================================================

-- ============================================================================
-- Migration 101: Create Pair Atomic
-- ============================================================================
-- Part 5.2: Atomic pairing engine - heart of the system
-- ============================================================================

-- Create pair atomically with FOR UPDATE SKIP LOCKED
CREATE OR REPLACE FUNCTION create_pair_atomic(
  p_user1_id UUID,
  p_user2_id UUID
) RETURNS BIGINT
LANGUAGE plpgsql
SECURITY DEFINER
SET statement_timeout TO '10s'
AS $$
DECLARE
  match_id BIGINT;
  user1_record RECORD;
  user2_record RECORD;
  locked_user1 BOOLEAN := FALSE;
  locked_user2 BOOLEAN := FALSE;
BEGIN
  -- 1. Lock both users using FOR UPDATE SKIP LOCKED (consistent order to prevent deadlocks)
  -- Always lock lower UUID first
  -- NOTE: Using profiles table (via users view)
  IF p_user1_id < p_user2_id THEN
    -- Lock user1 first
    SELECT * INTO user1_record
    FROM profiles
    WHERE id = p_user1_id
    FOR UPDATE SKIP LOCKED;
    
    IF NOT FOUND THEN
      RETURN NULL;
    END IF;
    
    locked_user1 := TRUE;
    
